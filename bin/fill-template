#!/usr/bin/env perl
use 5.010;
use strict;
use warnings;
use utf8;
use open qw< :std :encoding(UTF-8) >;
use FindBin qw< $Bin >;
use lib "$Bin/../lib", "$Bin/../local/lib/perl5";
use Getopt::Long::Descriptive;
use ISDB::Template;
use ISDB::Exporter;
use Path::Tiny;
use JSON::MaybeXS;
use ISDB::Config;

my ($opt, $usage) = describe_options(
    '%c [--output=directory] [--find-exports=directory] [template.tt]',
    [],
    [ "Renders the provided template and outputs the results on stdout" ],
    [ "or the given output directory." ],
    [],
    [ 'output|o=s',     "writes the filled template to the given directory as template.html" ],
    [ 'find-exports=s', "looks for exports in the given directory and provides metadata to the template" ],
    [ 'find-versions=s',"looks for all version.json files underneath the given directory and provides metadata to the template" ],
    [ 'var=s@',         "define a template variable like «--var foo=bar» for simple values or «--var foo\@bar.json» to read JSON for complex values" ],
    [ 'help',           "print usage message and exit" ],
);

print($usage->text), exit(!$opt->help)
    if $opt->help or not @ARGV;
die "--find-exports and --find-versions require the use of --output\n"
    if ($opt->find_exports or $opt->find_versions) and not $opt->output;

my $args   = {};
my $source = shift;
my $output = $opt->output
    ? path($opt->output)->child( path($source)->basename(".tt") . ".html" )->openw_utf8
    : \*STDOUT;

if ($opt->find_exports) {
    my $exporter = ISDB::Exporter->new( output_path => path($opt->find_exports) );
    my @exports  = $exporter->find_metadata;

    # Turn paths relative to the template
    for my $export (@exports) {
        for my $format (values %{ $export->{formats} }) {
            $format->{path} = path($format->{path})
                ->absolute($opt->find_exports)
                ->relative($opt->output)
                ->stringify;
        }
    }
    $args->{exports} = \@exports;
}

if ($opt->find_versions) {
    my $versions = path($opt->find_versions)->visit(
        sub {
            my ($path, $versions) = @_;
            $versions->{$path} = decode_json($path->slurp_raw)
                if $path->is_file
               and $path->basename eq "version.json";
        },
        { recurse => 1 },
    );
    $args->{versions} = [ values %$versions ];
}

my $pubmed_cache = path($Bin)->parent->child("cache", "pubmed.json");
$args->{pubmed_info} = decode_json( $pubmed_cache->slurp_raw )
    if $pubmed_cache->exists;

my $issues_cache = path($Bin)->parent->child("cache", "issues.json");
$args->{issues} = decode_json( $issues_cache->slurp_raw )
    if $issues_cache->exists;

$args->{config} = ISDB::Config->new->conf->{web};

# Read in passed template vars
for my $var (@{ $opt->var || [] }) {
    my ($name, $op, $value) = split /([=@])/, $var, 2;
    $value = decode_json( path($value)->slurp_raw )
        if $op eq "@";
    $args->{$name} = $value;
}

print { $output } ISDB::Template->fill($source, $args);
